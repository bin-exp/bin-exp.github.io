# Урок 1 - Введение в эксплуатацию бинарных уязвимостей

### Введение

Данный курс посвящен изучению эксплуатации бинарных уязвимостей на примере исполняемых файлов ОС Linux. Для отладки программ будет использоваться в основном отладчик GDB, сплоиты предполагается писать на языке python с использованием библиотеки pwn. В ходе курса будут рассмотрены базовые техники эксплуатации и способы защиты от них. На практике будут использоваться простые, небольшие по размеру консольные программы.

В данном уроке будут рассмотрены базовые понятия, необходимые для дальнейшего изучения.

### Основная часть

#### Язык ассемблер

**Язык ассемблера** — символьная форма записи машинного кода, использование которого упрощает написание машинных программ. Команды языка ассемблера один к одному соответствуют командам процессора. Каждая модель (или семейство) процессоров имеет свой набор — систему — команд и соответствующий ему язык ассемблера. Наиболее популярные синтаксисы — **Intel** и **AT&T**. Эти синтаксисы представляют одни и те же команды по-разному:

```assembly
mov eax, ebx (Intel)
movl %ebx, %eax (AT&T)
```

В рамках курса будем использовать синтаксис Intel.

Общий формат записи инструкций одинаков для обоих стандартов:

`[метка:] опкод [операнды] [;комментарий]`

**Опкод** — это и есть собственно ассемблерная команда, мнемоника инструкции процессору. В качестве операндов могут выступать константы, названия регистров, адреса в оперативной памяти и так далее. Различия между стандартами Intel и AT&T касаются в основном порядка перечисления операндов и их синтаксиса при разных методах адресации.

В среде ОС UNIX более популярен синтаксис типа AT&T, однако учебных пособий по нему нет, он описывается исключительно в справочной и технической литературе. Поэтому логично выбрать ассемблер на основе синтаксиса Intel. Для UNIX-систем есть два основных ассемблера — это NASM (Netwide Assembler) и FASM (Flat Assembler). Для линейки Windows популярностью пользуются FASM и MASM (Macro Assembler) от фирмы Microsoft, и также существовал еще TASM (Turbo Assembler). Будем использовать **NASM** в виду его кроссплатформенности.

[список основных команд](https://github.com/bin-exp/bin-exp.github.io/blob/master/docs/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20ASM/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20ASM.md)

#### Организация памяти программы 

Каждый процесс в многозадачной ОС работает в своей «песочнице» в памяти. Это виртуальное адресное пространство, которое в 32-битном режиме представляет собою 4Гб блок адресов. Эти виртуальные адреса ставятся в соответствие (mapping) физической памяти таблицами страниц, которые поддерживает ядро ОС. У каждого процесса есть свой набор таблиц. Но если мы начинаем использовать виртуальную адресацию, приходится использовать её для всех программ, работающих на компьютере – включая и само ядро. Поэтому часть пространства виртуальных адресов необходимо резервировать под ядро.

Таким образом виртуальное пространство программы состоит из:

- Kernel space
- Stack
- Mmap segment
- Heap
- BSS segment
- Data segment
- Text segment



![memory_organization](data/memory_organization.png)

##### Пространство ядра

Пространство памяти для ядра отмечено в таблицах страниц как эксклюзивно используемое привилегированным кодом, поэтому если какая-то программа пытается получить в него доступ, случается page fault. В Linux пространство памяти для ядра присутствует постоянно, и ставит в соответствие одну и ту же часть физической памяти у всех процессов. Код ядра и данные всегда имеют адреса, и готовы обрабатывать прерывания и системные вызовы в любой момент.

##### Стек

**Стек** - это область оперативной памяти для временного хранения данных, удобство
использования в отличие от сегментов данных заключается в том, что не надо
именовать отдельные ячейки для записи. Стек адресуется относительно сегментного
регистра SS. Ширина стека это размер элементов которые можно в него помещать. На
примере это 16 бит. Регистр SP Содержит адрес последнего добавленного элемента, он же
называется вершиной стека.

![stack1](data/stack1.png)

push/pop:

![stack2](data/stack2.png)

![stack3](data/stack3.png)

![stack4](data/stack4.png)

##### Сегмент отображения в память

Тут ядро размещает содержимое файлов напрямую в памяти. Любое приложение может запросить сделать это через системный вызов mmap() в Linux или CreateFileMapping() / MapViewOfFile() в Windows. Это удобный и быстрый способ организации операций ввода и вывода в файлы, поэтому он используется для подгрузки динамических библиотек. Также возможно создать анонимное место в памяти, не связанное с файлами, которое будет использоваться для данных программы.

##### Куча

Она обеспечивает выделение памяти во время выполнения программы, как и стек – но, в отличие от него, хранит те данные, которые должны пережить функцию, размещающую их. В большинстве языков есть инструменты для управления кучей. В этом случае удовлетворение запроса на размещение памяти выполняется совместно программой и ядром. В С интерфейсом для работы с кучей служит malloc().

##### Сегмент неинициализированных данных (BSS)

BSS и данные хранят статичные (глобальные) переменные в С. Разница в том, что BSS хранит содержимое непроинициализированных статичных переменных, чьи значения не были заданы программистом. 

Пример:

```c
int a;
char* str;

int main()
{}
```

```c
static char* username;
```

##### Сегмент инициализированных данных 

Сегмент данных, наоборот, содержит те переменные, которые были проинициализированы в коде. Эта часть памяти соответствует бинарному образу программы, содержащему начальные статические значения, заданные в коде.

Пример:

```c
char* hello = "Hello, world!";
int len = 256;
```

##### Сегмент текста

Здесь находится сам исполняемый код программы, таблицу plt, таблицы для switch.

#### Регистры

**Регистры процессора** - внутренние ячейки процессора, которые служат для хранения информации с практически мгновенным доступом. В отличии от оперативной памяти, для чтения и записи в регистры не нужно обращаться к внешнему устройству через шину, потому что регистры встроены в процессор и являются одной из его основных частей.

Список регистров процессора (x86):

| Регистры общего назначения                                   | Сегментные регистры                        | Служебные регистры    |
| ------------------------------------------------------------ | ------------------------------------------ | --------------------- |
| EAX<br />EBX<br />ECX<br />EDX<br />ESP<br />EBP<br />ESI<br />EDI | CS<br />DS<br />SS<br />ES<br />FS<br />GS | EFLAGS<br />EIP<br /> |

Список регистров процессора (x64):

| Регистры общего назначения                                   | Служебные регистры |
| ------------------------------------------------------------ | ------------------ |
| RAX<br />RBX<br />RCX<br />RDX<br />RSP<br />RBP<br />RSI<br />RDI<br />R8 - R15 | RFLAGS<br />RIP    |

**Регистры общего назначения** - служат для хранения информации внутри процессора. Этот тип регистров отличает то, что они могут быть использованы в арифметических операциях и в них возможна запись значений с помощью команды MOV.

**Сегментные регистры** используются при формировании линейных адресов памяти. Вторым компонентом для формирования линейного адреса является смещение, называемое также эффективным адресом. Способ вычисления линейного адреса зависит от режима работы процессора.

[more](https://github.com/bin-exp/bin-exp.github.io/blob/master/docs/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0/%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B.md)

#### Флаги и условные переходы

Регистр флагов носит название **EFLAGS**. Это 32-разрядный регистр. Однако старшие 16 разрядов используются при работе в защищённом режиме, и пока мы их рассматривать не будем. К младшим 16 разрядам этого регистра можно обращаться как к отдельному регистру с именем FLAGS. Именно этот регистр мы и рассмотрим в этом разделе.

Каждый бит в регистре **FLAGS** является флагом. **Флаг** – это один или несколько битов памяти, которые могут принимать двоичные значения (или комбинации значений) и характеризуют состояние какого-либо объекта. Обычно флаг может принимать одно из двух логических значений. Поскольку в нашем случае речь идёт о бите, то каждый флаг в регистре может принимать либо значение 0, либо значение 1. Флаги устанавливаются в 1 при определённых условиях, или установка флага в 1 изменяет поведение процессора.

| Бит      | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **Флаг** | 0    | NT   | IOPL | IOPL | OF   | DF   | IF   | TF   | SF   | ZF   | 0    | AF   | 0    | PF   | 1    | CF   |

Не все флаги являются полезными для нас. Рассмотрим условные переходи, которые зависят от некоторых флагов:

| Команда     | Состояние флагов | Условие для CMP                             |
| ----------- | ---------------- | ------------------------------------------- |
| **JA**      | CF=0 и ZF=0      | если выше                                   |
| **JAE/JNC** | CF=0             | если меньше или равно<br/>если нет переноса |
| **JB/JC**   | CF=1             | если меньше<br/>если перенос                |
| **JBE**     | CF=1 или ZF=1    | если меньше или равно                       |
| **JE/JZ**   | ZF=1             | если равно<br/>если ноль                    |
| **JO**      | OF=1             | если есть переполнение                      |
| **JS**      | SF=1             | если есть знак                              |
| **JP**      | PF=1             | если есть четность                          |
| **JG**      | ZF=0 и SF=OF     | если больше                                 |
| **JGE**     | SF=OF            | если больше или равно                       |
| **JL**      | SF<>OF           | если меньше                                 |
| **JLE**     | ZF=1 или SF<>OF  | если меньше или равно                       |
| **JNE/JNZ** | ZF=0             | если не равно<br/>если не ноль              |
| **JNO**     | OF=0             | если нет переполнения                       |
| **JNS**     | SF=0             | если нет знака                              |
| **JNP**     | PF=0             | если нет четности                           |

#### Системные вызовы в Linux

Системный вызов --- это основной интерфейс между приложением и ядром Linux.

Осуществляется для выполнения системных функций ядром - открытие/закрытие файлов, чтение/запись, создание сокетов, установка прав и многое другое. В x86 осуществляется путем вызова системного прерывания `int 0x80` с соответствующими параметрами. которые заблаговременно были помещены в регистры. В x86_64 - с помощью функции `syscall()`.

[Таблица syscall'ов для x86](https://github.com/bin-exp/bin-exp.github.io/blob/master/docs/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D1%8B%20%D0%B2%20Linux/linux_syscalls_x86.md)

[Таблица syscall'ов для x86_64](https://github.com/bin-exp/bin-exp.github.io/blob/master/docs/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D1%8B%20%D0%B2%20Linux/linux_syscalls_x64.md)

#### Простейшая программа - Hello, pwners!

Рассмотрим теперь простейшую программу на языке Си.

```c
#include <stdio.h>

int main()
{
	printf("Hello, pwners!\n");
	return 0;
}
```

Скомпилируем ее компилятором gcc в 32-битный исполняемый файл:

```sh
$ gcc -m32 hello.c -o hello 
```

Получим следующий дизассемблированный код любой удобной программой:

```assembly
   0x56556199 <+0>:	    lea    ecx,[esp+0x4]		; 
   0x5655619d <+4>:	    and    esp,0xfffffff0		
   0x565561a0 <+7>:  	push   DWORD PTR [ecx-0x4]
   0x565561a3 <+10>:	push   ebp
   0x565561a4 <+11>:	mov    ebp,esp
   0x565561a6 <+13>:	push   ebx
   0x565561a7 <+14>:	push   ecx
   0x565561a8 <+15>:	call   0x565561d5 <__x86.get_pc_thunk.ax>
   0x565561ad <+20>:	add    eax,0x2e53
   0x565561b2 <+25>:	sub    esp,0xc
   0x565561b5 <+28>:	lea    edx,[eax-0x1ff8]
   0x565561bb <+34>:	push   edx
   0x565561bc <+35>:	mov    ebx,eax
   0x565561be <+37>:	call   0x56556030 <puts@plt>
   0x565561c3 <+42>:	add    esp,0x10
   0x565561c6 <+45>:	mov    eax,0x0
   0x565561cb <+50>:	lea    esp,[ebp-0x8]
   0x565561ce <+53>:	pop    ecx
   0x565561cf <+54>:	pop    ebx
   0x565561d0 <+55>:	pop    ebp
   0x565561d1 <+56>:	lea    esp,[ecx-0x4]
   0x565561d4 <+59>:	ret    
```



#### Сетевой клиент и сервер





#### Как выглядят процессы в памяти Linux



#### права на память



#### процесс загрузки 





### Заключение





