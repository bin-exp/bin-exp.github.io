# Основные команды ASM
   * [Основные команды ASM](#основные-команды-asm)
            * [Команды пересылки данных](#команды-пересылки-данных) 
                  * [<strong>MOV</strong>](#mov) 
                  * [<strong>MOVZX</strong>](#movzx) 
                  * [<strong>MOVSX</strong>](#movsx) 
                  * [<strong>XCHG</strong>](#xchg) 
                  * [<strong>CBW</strong>](#cbw) 
                  * [<strong>CWD</strong>](#cwd) 
                  * [<strong>CWDE</strong>](#cwde) 
                  * [<strong>CDQ</strong>](#cdq) 
            * [Команды для пересылки цепочки данных](#команды-для-пересылки-цепочки-данных) 
                  * [<strong>MOVS</strong>](#movs) 
                  * [<strong>MOVSB</strong>](#movsb) 
                  * [<strong>MOVSW</strong>](#movsw) 
                  * [<strong>MOVSD</strong>](#movsd) 
            * [Команды работы со стеком](#команды-работы-со-стеком)   
                  * [<strong>PUSH</strong>](#push) 
                  * [<strong>POP</strong>](#pop) 
                  * [<strong>PUSHA</strong>](#pusha) 
                  * [<strong>POPA</strong>](#popa) 
                  * [<strong>PUSHF</strong>](#pushf) 
            * [Арифметические операции](#арифметические-операции)     
                  * [<strong>ADD</strong>](#add) 
                  * [<strong>SUB</strong>](#sub) 
                  * [<strong>MUL</strong>](#mul) 
                  * [<strong>DIV</strong>](#div) 
                  * [<strong>INC/DEC</strong>](#incdec)    
            * [Команды передачи управления](#команды-передачи-управления) 
                  * [<strong>JMP</strong>](#jmp) 
                  * [<strong>CALL</strong>](#call) 
                  * [<strong>RET</strong>](#ret) 
            * [Команды для организации циклического выполнения программ](#команды-для-организации-циклического-выполнения-программ) 
                  * [<strong>LOOP</strong>](#loop)        
            * [Логические операции](#логические-операции) 
                  * [<strong>AND</strong>](#and) 
                  * [<strong>OR</strong>](#or) 
                  * [<strong>XOR</strong>](#xor) 
                  * [<strong>TEST</strong>](#test) 
                  * [<strong>NOT</strong>](#not) 

#### Команды пересылки данных

MOV, XCHG, CBW, CWDE

###### **MOV**

mov приемник, источник

приемник = источник

|  Приемником м.б.   |      Источником м.б.      |
| :----------------: | :-----------------------: |
|   Область памяти   |      Область памяти       |
|        РОН         |            РОН            |
| Сегментный регистр |    Сегментный регистр     |
|                    | Непосредственное значение |

MOV не может:

​	1) Записывать данные в регистры CS и IP.
​	2) Копировать данные из одного сегментного регистра в другой сегментный регистр (сначала нужно скопировать данные в регистр общего назначения).
​	3) Копировать непосредственное значение в сегментный регистр (сначала нужно скопировать данные в регистр общего назначения).

###### **MOVZX**

Команда MOVZX копирует содержимое исходного операнда в больший по размеру регистр получателя данных. При этом **оставшиеся неопределенными биты регистра-получателя (как правило, старшие 16 или 24 бита) сбрасываются в ноль.** Эта команда используется только при работе с беззнаковыми целыми числами.

MOVSX/MOVZX 16-разрядный регистр (16r), 8-разрядный регистр или поле памяти(8r/8m)
MOVSX/MOVZX 32-разрядный регистр (32r), 8-разрядный регистр или поле памяти(8r/8m)
MOVSX/MOVZX 32-разрядный регистр (32r), 16-разрядный регистр или поле памяти(16r/16m)

###### **MOVSX**

Команда MOVSX (Move With Sign-Extend, или Переместить и дополнить знаком) копирует содержимое исходного операнда в больший по размеру регистр получателя данных, также как и команда MOVZX. При этом **оставшиеся неопределенными биты регистра- получателя (как правило, старшие 16 или 24 бита) заполняются значением знакового бита исходного операнда**. Эта команда используется только при работе со знаковыми целыми числами.

Команды MOVSX и MOVZX применимы к следующим операндам:

MOVSX/MOVZX 16-разрядный регистр (16r), 8-разрядный регистр или поле памяти(8r/8m)
MOVSX/MOVZX 32-разрядный регистр (32r), 8-разрядный регистр или поле памяти(8r/8m)
MOVSX/MOVZX 32-разрядный регистр (32r), 16-разрядный регистр или поле памяти(16r/16m)

###### **XCHG** 

**(Exchange Data)**

xchg *операнд*_1, операнд_2

обменивает содержимое двух операндов

операндами команды xchg не могут являться непосредственные значения 

###### **CBW** 

 **(Convert byte to word)**

Выполняет преобразование значения, находящегося в регистре **al**, до размера слова, и помещает его в ах, при этом свободные старшие биты ах заполняются знаковым битом al **(al -> ax)**

```assembly
Mov al, 1; al =  00000001b
Cbw; ax = 00000000 00000001b
```

###### **CWD**

Выполняет преобразование значения, находящегося в регистре **ax**, до размера двойного слова, и помещает его в пару регистров dx:ах, при этом свободные биты dx заполняются знаковым битом aх. **(ax -> dx:ax)**

```assembly
Mov ax, 1; ax =  00000000 00000001b
Cwd; dx = 00000000 00000000 ax =  0000000 00000001b
```

###### **CWDE**

Выполняет преобразование значения, находящегося в регистре **ax**, до размера двойного слова, и помещает его в регистр eах, при этом свободные старшие биты eax заполняются знаковым битом aх. **(ax -> eax)**

`Mov ax, 1;`  ax =  00000000 00000001b
`Cwde;` eax = 00000000 00000000 00000000 00000001b

###### **CDQ**

Выполняет преобразование значения, находящегося в регистре eax, до размера учетверенного слова, и помещает его в пару регистров **edx:eах**, при этом свободные биты edx заполняются знaковым битом eax. **(eax -> edx:eax)**

```assembly
Mov eax, 1; eax =  00000000 00000000 00000000 00000001b
Cdq;
edx =  00000000 00000000 00000000 00000000b
eax =  00000000 00000000 00000000 00000001b
```

#### Команды для пересылки цепочки данных

###### **MOVS** 

**movs** приемник, источник

###### **MOVSB** 

**movsb** — переслать цепочку байтов;

###### **MOVSW**

**movsw** — переслать цепочку слов;

###### **MOVSD** 

**movsd**— переслать цепочку двойных слов.

Команда копирует байт, слово или двойное слово из цепочки, адресуемой ds:si, в цепочку, адресуемую ds:si (Для **MOVS** адреса приемника и источника указываются при вызове )

Есть также и другие команды, главное запомните, что на конце если в конце слова B, W, D то стоит загуглить команды для работы с цепочкой данных

#### Команды работы со стеком

**PUSH, POP, PUSHA, POPA, PUSHF**

###### **PUSH**

Команда PUSH выполняет запись значения «источник» в вершину стека.

**push** источник

Алгоритм работы этой команды, включает два действия:

- Значение ESP уменьшается на 4 (RSP на 8)

- Значение источника записывается по адресу, указываемому парой SS:ESP.

То есть аналогом команды `push eax` является:

```assembly
sub esp, 4
mov [esp], eax
```

###### **POP** 

Команда POP выполняет запись значения из вершины стека по месту, указанному операндом «приемник» (значение при этом «снимается» с вершины стека)

**pop** источник

Алгоритм работы команды POP обратен алгоритму команды PUSH

- Запись содержимого вершины стека по месту, указанному операндом «приемник».

- Увеличение значения SP на 4

То есть аналогом команды `pop eax` является:

```assembly
mov eax, [esp]
add esp, 4
```

###### **PUSHA**

Команда PUSHA предназначена для групповой записи в стек. По этой команде в стек последовательно записывается содержимое регистров АХ, СХ, DX, BX, SP, BP, SI, DI.

**pusha**

###### **POPA** 

Обратная ей команда POPA выталкивает из стека в соответствующие регистры переданные значения в обратном порядке – DI, SI, BP, SP, BX, DX, CX, AX.

**popa**

###### **PUSHF** 

**pushf** - сохраняет регистр флагов в стеке

#### Арифметические операции

**ADD, SUB, MUL, DIV**

###### **ADD**

add приемник, источник 

приемник = приемник + источник. 

| Приемником м.б. |      Источником м.б.      |
| :-------------: | :-----------------------: |
| Область памяти  |      Область памяти       |
|       РОН       |            РОН            |
|                 | Непосредственное значение |

###### **SUB**

sub приемник, источник 

приемник = приемник - источник

На самом деле SUB в процессоре реализовано с помощью сложения. Процессор меняет знак второго операнда на противоположный, а затем складывает два числа. Если вам необходимо в программе поменять знак числа на противоположный, можно использовать команду NEG.

###### **MUL**

Операция умножения

mul число

| Если число - байт | Если число - слово |
| ----------------- | ------------------ |
| AX=AL*число       | (DX AX)=AX*число   |

В случае если не хватает Al, переходим в AH

Числом может быть:

​	1)Область памяти

​	2)РОН

Команда MUL не работает с:

​	1)Сегментными регистрами

​	2)Непосредственными значениями

###### **DIV**

div число

| Если число - байт                     | Если число - слово                          |
| ------------------------------------- | ------------------------------------------- |
| AL=AX/число,  в AH остаток от деления | AX=(DX AX)/число, в DX - остаток от деления |

Числом может быть:

​	1)Область памяти

​	2)РОН

###### **INC/DEC**

**INC** - инкремент

Inc число

В качестве числа могут выступать область памяти и РОН

**DEC** декремент

Dec число

В качестве числа могут выступать область памяти и РОН

**INC/DEC** изменяют флаги

 

#### Команды передачи управления

**Команды для безусловной передачи управления:**

**CALL  и RET** – вызов и возврат из процедуры

**INT и IRET** – вызов и возврат из прерывания

###### **JMP** 

**JMP** [модификатор] <адрес перехода> – безусловный переход

[модификатор]

- near ptr ([прямой переход](https://indigobits.com/assembler/15-klassifikaciya-perexodov.html) на метку внутри сегмента кода),
- far ptr ([прямой переход](https://indigobits.com/assembler/15-klassifikaciya-perexodov.html) на метку в другом сегменте кода),
- word ptr ([косвенный переход](https://indigobits.com/assembler/15-klassifikaciya-perexodov.html) по адресу внутри сегмента кода),
- dword ptr ([косвенный переход](https://indigobits.com/assembler/15-klassifikaciya-perexodov.html) по адресу в другом сегменте)

**Команды условной передачи управления** 

Эти команды выполняют переход, если выполняются определенные условия

| Команда     | Состояние флагов | Условие для CMP                           |
| ----------- | ---------------- | ----------------------------------------- |
| **JA**      | CF=0 и ZF=0      | если выше                                 |
| **JAE/JNC** | CF=0             | если выше или равно<br/>если нет переноса |
| **JB/JC**   | CF=1             | если ниже<br/>если перенос                |
| **JBE**     | CF=1 или ZF=1    | если ниже или равно                       |
| **JE/JZ**   | ZF=1             | если равно<br/>если ноль                  |
| **JO**      | OF=1             | если есть переполнение                    |
| **JS**      | SF=1             | если есть знак                            |
| **JP**      | PF=1             | если есть четность                        |
| **JG**      | ZF=0 и SF=OF     | если больше                               |
| **JGE**     | SF=OF            | если больше или равно                     |
| **JL**      | SF<>OF           | если меньше                               |
| **JLE**     | ZF=1 или SF<>OF  | если меньше или равно                     |
| **JNE/JNZ** | ZF=0             | если не равно<br/>если не ноль            |
| **JNO**     | OF=0             | если нет переполнения                     |
| **JNS**     | SF=0             | если нет знака                            |
| **JNP**     | PF=0             | если нет четности                         |

**JECXZ**  переходит, если ecx=0

###### **CALL**

**call** <метка>

вызов процедуры с сохранением в стеке адреса возврата (32-битное число) 

###### **RET**

**ret** или (**ret** число) – выход из процедуры. Если число указано, то после считывания адреса возврата из стека будет удалено указанное число байтов. Указывается именно число, а не регистр. Бывает нужно, если при вызове процедуры параметры ей передавались через стек 

#### Команды для организации циклического выполнения программ

###### **LOOP**

loop <метка>

Уменьшает регистр ecx на 1 и выполняет переход типа short (не дальше, чем на 127 байт) на метку, если ecx<>0. Например, в следующем фрагменте команда **add** выполнится 10 раз: 

```assembly
mov ecx, 10; 
@loop_start:     
add eax, ecx;
loop @loop_start;
```

#### Логические операции

**AND, OR, XOR, TEST, NOT**

###### **AND** 

AND - побитовое логическое умножение. Используют для выделения части битов.

```assembly
mov bx, 01101001b
mov bl, 01000111b
and bx, bl
```

Результат записывается в регистр, который стоит первым после оператора **and**, в нашем случае — это регистр **bx**, то есть теперь его значение поменялось на 01000001.

###### **OR** 

OR — Побитовое логическое сложение. Используют вместо команд сравнения

```assembly
mov bx,01101001b
mov bl,01000111b
or bx, bl
```

Выполнение этой инструкции вернет 01101111 и поместит это двоичное число в регистр **bx**.

###### **XOR**

XOR — Побитовое сложение по модулю два. Используют для обнуления.

```assembly
1100 XOR 1010 = 0110
1010 XOR 1010 = 0000
```

Аналогично **OR**

###### **TEST** 

TEST— Выполняется логическое умножение, но приемник не меняется. Меняются только флаги.

###### **NOT** 

NOT— Инвертирует каждый бит. Все предыдущие команды, кроме NOT, изменяют флаги zf, cf, of, pf, sf

```assembly
NOT 1010 = 0101
```
